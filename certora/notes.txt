
// questions / observations:
MerkleMinter.claimKatToken can be called with amount = 0
KatToken.distributeInflation: wouldn't it be better to add a check block.timestamp > lastMintCapacityIncrease at the beginning to save execution of the other commands?
KatToken.distributeMintCapacity are the checks on lines 200 and 201 needed?
KatToken.distributeMintCapacity can we use unchecked instead?
KatToken: line 170 can't we have >= instead of > ?
inflationBeneficiary and inflationAdmin: wouldn't it be better to use the existing Ownable interface?
    - the new owner cannot decline
    - it can change to the same value
there's no check that merkleMinter is actually a MerkleMinter contract

----------------------------------

more questions:

L/info finding:
the MerkleMinter.init function is very dangerous because the operation can only work if the new tree respects the same indexes (i.e. append-only), which is a very strict requirement for off-chain components.
Otherwise, thereâ€™s risk of one claiming twice if their claim is available under different indexes before and after the root update 


L/info finding (this was discussed during the call with the team) KatToken.renounceInflationBeneficiary can be called when inflationFactor is non-zero. This will grant mint capacity to address(0) which is certainly unwanted. Fix is to require (or overwrite) inflationFactor to be zero when the inflationBeneficiary is reset
WHY IS IT A PROBLEM?


// properties:
----------------
Powutil:

exp2(x) == 2^x , formally: exp2(x *1e18) == 2^x *1e18
exp2(x+y) == exp2(x)*exp2(y) , formally: exp2(x+y) *1e18 == exp2(x)*exp2(y) 
exp2(x) <= exp2(x+1)
lower and upper bounds: LB(x) <= exp2(x) <= UB(x) currently we're using bounds based on 3rd-order Taylor expansions
 + more variants of these. With error bounds, etc.

----------------
merkleminter:

katToken and root can only change via init                                                  
locked can only change from true -> false                                   
rootSetter can only change from x -> 0                                      
only rootSetter can call init                                               
only unlocker can call unlock                                               
all calls to claimKatToken must revert before unlockTime unless already unlocked    
claimKatToken will increase receiver's balance when executed successfully               not written
once active, the protocol will not go to an inactive state, i.e., (block.timestamp > unlockTime || !locked) can only change false -> true
indexIsClaimed(index) can only change false -> true
indexIsClaimed(index) == true => claimKatToken(..,index) will revert
init cannot be called after the minter is unlocked i.e., after ((block.timestamp > unlockTime) || !locked)
It should not be possible to permanently renounce the rootSetter role without actually setting the root first

----------------
katToken:

only certain methods may increase/decrease total mint capacity  
total mint capacity + mintedTokens can only increase                                w
lastMintCapacityIncrease can only increase                                          w              
distributedSupplyCap can only increase                                              w                    
distributedSupplyCap == total mint capacity + mintedTokens                          w   
for all x: mintCapacity[x] <= distributedSupplyCap                              xx
mintCapacity of address(0) is always 0                                              w
inflation <= MAX_INFLATION                                                          w
inflation can be set to any value <= MAX_INFLATION       
    if value <= MAX_INFLATION then "satisfy" inflation == value
    forall v satisfy 
    
                           w
once renounceInflationAdmin is performed, the inflationAdmin will always be zero
    1. show that renounceInflationAdmin sets inflationAdmin to 0
    2. show that inflationAdmin can never change from 0 to non-zero                 w
the same for inflationBeneficiary
    1. show that renounceInflationAdmin sets inflationBeneficiary to 0
    2. show that inflationBeneficiary can never change from 0 to non-zero           w
only inflationBeneficiary can change inflationBeneficiary                           w
only inflationAdmin can change inflationAdmin                                       w

----------------
more properties:

KatToken.sol
158:         require(value < MAX_INFLATION, "Inflation too large.");
can we write a rule that shows that all values within range must succeed?

given any of the privileged addresses (KatToken.inflationAdmin, KatToken.inflationBeneficiary, MerkleMinter.rootSetter), once the corresponding renounce function is called, the given privileged address must remain address(0) indefinitely

mutations..??

any more properties?

1000 year inflation -> 5e18, maybe use 10e18 instead . use this: 43e18

minimum arg to exp2 is about 6M but not a multiplier of it


during the handover

show a simple but powerful rule, show mutation
